#
# (C) Copyright 2014 Google, Inc
# Simon Glass <sjg@chromium.org>
#
# SPDX-License-Identifier:	GPL-2.0+
#

Background
----------

U-Boot traditionally had a board.c file for each architecture.
传统上，U-Boot对于每种体系结构都有一个board.c文件。
 This introducedquite a lot of duplication, with each architecture tending to do initialisation slightly differently. 
 这引入了很多重复，每种架构的初始化趋向略有不同。
 To address this, a new 'generic board init' feature was introduced in March 2013 (further motivation is provided in the cover letter below).
为了解决这个问题，2013年3月引入了新的“通用板初始化”功能（进一步的动机在下面的自荐信中提供）。
All boards and architectures have moved to this as of mid 2016.
截至2016年中，所有主板和架构均已移至此。


What has changed?
-----------------

The main change is that the arch/<arch>/lib/board.c file is removed in favour of common/board_f.c (for pre-relocation init) and common/board_r.c(for post-relocation init).
主要更改是删除了arch / <arch> /lib/board.c文件，以便使用common / board_f.c（用于重定位前初始化）和common / board_r.c（用于重定位后初始化）。
Related to this, the global_data and bd_t structures now have a core set of fields which are common to all architectures. 
与此相关的是，global_data和bd_t结构现在具有一组核心字段，这些字段对于所有体系结构都是通用的。
Architecture-specific fields have been moved to separate structures.
特定于体系结构的字段已移至单独的结构。

Further Background
------------------

The full text of the original generic board series is reproduced below.
原始通用电路板系列的全文复制如下。
--8<-------------

This series creates a generic board.c implementation which contains the essential functions of the major arch/xxx/lib/board.c files.
本系列创建一个通用的board.c实现，其中包含主要arch / xxx / lib / board.c文件的基本功能。
What is the motivation for this change?
这种变化的动机是什么？
1. There is a lot of repeated code in the board.c files. 
board.c文件中有很多重复的代码。
Any change tothings like setting up the baud rate requires a change in 10 separate places.
诸如设置波特率之类的任何更改都需要在10个单独的位置进行更改。
2. Since there are 10 separate files, adding a new feature which requires initialisation is painful since it must be independently added in 10 places.
由于有10个单独的文件，因此添加一个需要初始化的新功能很麻烦，因为必须在10个地方独立添加。
3. As time goes by the architectures naturally diverge since there is limited pressure to compare features or even CONFIG options against similar things in other board.c files.
随着时间的流逝，体系结构自然会发生分歧，因为将功能甚至CONFIG选项与其他board.c文件中的相似事物进行比较的压力有限。
4. New architectures must implement all the features all over again, and sometimes in subtle different ways. 
新架构必须重新实现所有功能，有时还需要以微妙的不同方式实现。
This places an unfair burden on getting a new architecture fully functional and running with U-Boot.
这给使新架构充分发挥功能并与U-Boot一起运行产生了不公平的负担。
5. While it is a bit of a tricky change, I believe it is worthwhile and achievable. 
尽管这是一个棘手的更改，但我认为这是值得且可以实现的。
There is no requirement that all code be common, only that the code that is common should be located in common/board.c rather than arch/xxx/lib/board.c.
不需要所有代码都通用，只要求通用代码应位于common / board.c中，而不是arch / xxx / lib / board.c中。
All the functions of board_init_f() and board_init_r() are broken into separate function calls so that they can easily be included or excluded for a particular architecture.
board_init_f（）和board_init_r（）的所有功能都分为单独的函数调用，因此可以为特定体系结构轻松包含或排除它们。
 It also makes it easier to adopt Graeme's initcall proposal when it is ready.
准备就绪后，也可以更轻松地采用Graeme的initcall建议。
http://lists.denx.de/pipermail/u-boot/2012-January/114499.html

This series removes the dependency on generic relocation. So relocation happens as one big chunk and is still completely arch-specific. 
本系列消除了对泛型重定位的依赖。所以重新定位是作为一个大的块发生的，仍然是完全特定于arch的。
See the relocation series for a proposed solution to this for ARM:
请参阅重定位系列以获取针对ARM的解决方案的建议方案：
http://lists.denx.de/pipermail/u-boot/2011-December/112928.html

or Graeme's recent x86 series v2:

http://lists.denx.de/pipermail/u-boot/2012-January/114467.html

Instead of moving over a whole architecture, this series takes the approach of simply enabling generic board support for an architecture. 
本系列文章并没有介绍整个架构，而是采用了简单地为架构启用通用板卡支持的方法。
It is then up to each board to opt in by defining CONFIG_SYS_GENERIC_BOARD in the board config file. 
然后，通过在板配置文件中定义CONFIG_SYS_GENERIC_BOARD来决定是否加入每个板。
If this is not done, then the code will be generated asbefore. 
如果没有这样做，那么代码将像以前一样生成。
This allows both sets of code to co-exist until we are comfortable with the generic approach, and enough boards run.
这允许两组代码共存，直到我们对通用方法感到满意并且运行了足够的电路板为止。
ARM is a relatively large board.c file and one which I can test, therefore I think it is a good target for this series. 
ARM是一个相对较大的board.c文件，我可以对其进行测试，因此我认为它是本系列的不错的目标。
On the other hand, x86 is relatively small and simple, but different enough that it introduces a few issues to be solved. 
另一方面，x86相对较小和简单，但又相差甚远，因此引入了一些要解决的问题。
So I have chosen both ARM and x86 for this series.After a suggestion from Wolfgang I have added PPC also. 
因此在本系列中我选择了ARM和x86。在Wolfgang的建议下，我还添加了PPC。
This is the largest and most feature-full board, so hopefully we have all bases covered in this RFC.
这是最大的、功能最丰富的板，所以希望我们已经在这个RFC中涵盖了所有的基础
A generic global_data structure is also required. This might upset a few people. 
还需要通用的global_data结构。这可能会使一些人不高兴。
Here is my basic reasoning: most fields are the same, all architectures include and need it, most global_data.h files already have #ifdefs to select fields for a particular SOC, so it is hard to see why architecures are different in this area. 
这是我的基本理由：大多数字段都是相同的，所有体系结构都包含并需要它，大多数global_data.h文件已经具有#ifdefs来选择特定SOC的字段，因此很难理解为什么该领域的体系结构不同。
We can perhaps add a way to put architecture-specific fields into a separate header file, but for now I have judged that to be counter-productive.
我们也许可以添加一种将特定于体系结构的字段放入单独的头文件中的方法，但是到目前为止，我认为这样做会适得其反
Similarly we need a generic bd_info structure, since generic code will be accessing it.
同样，我们需要一个通用的bd_info结构，因为通用代码将对其进行访问。
 I have done this in the same way as global_data and the same comments apply.
我以与global_data相同的方式完成了此操作，并应用了相同的注释。
There was dicussion on the list about passing gd_t around as a parameter to pre-relocation init functions. 
关于将gd_t作为参数传递给预重定位init函数的问题，列表上没有定论。
I think this makes sense, but it can be done as a separate change, and this series does not require it.
我认为这很有意义，但是可以将其作为单独的更改来完成，而本系列则不需要。
While this series needs to stand on its own (as with the link script cleanup series and the generic relocation series) the goal is the unification of the board init code.
尽管该系列需要独立（与链接脚本清除系列和通用重定位系列一样），但目标是统一板初始化代码。
 So I hope we can address issues with this in mind, rather than focusing too narrowly on particular ARM, x86 or PPC issues.
所以我希望我们能在脑海中解决这个问题，而不是局限于特定的ARM、x86或PPC问题。
I have run-tested ARM on Tegra Seaboard only. To try it out, define CONFIG_SYS_GENERIC_BOARD in your board file and rebuild. 
我仅在Tegra Seaboard上对ARM进行了运行测试。要进行尝试，请在您的电路板文件中定义CONFIG_SYS_GENERIC_BOARD并重新生成。
Most likely on x86 and PPC at least it will hang, but if you are lucky it will print something first :-)
最有可能在x86和PPC上至少会挂起，但是如果幸运的话，它会先打印一些内容：-)
I have run this though MAKEALL with CONFIG_SYS_GENERIC_BOARD on for all ARM, PPC and x86 boards. 
我通过在所有ARM，PPC和x86板上使用CONFIG_SYS_GENERIC_BOARD进行了MAKEALL操作。
There are a few failures due to errors in the board config, which I have sent patches for. 
由于电路板配置中的错误，导致了一些故障，我已为其发送了补丁程序。
The main issue is just the difference between __bss_end and __bss_end__.
主要问题只是__bss_end和__bss_end__之间的区别。
Note: the first group of commits are required for this series to build,but could be separated out if required. 
注意：本系列的构建需要第一批提交，但是如果需要可以将它们分开。
I have included them here for convenience.
为了方便起见，我将它们包括在这里。
------------->8--

Simon Glass, sjg@chromium.org
March 2014
Updated after final removal, May 2016
