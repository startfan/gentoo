Generic SPL framework
=====================

Overview
--------

To unify all existing implementations for a secondary program loader (SPL) and to allow simply adding of new implementations this generic SPL framework has been created. 
为了统一辅助程序加载器（SPL）的所有现有实现，并允许简单地添加新的实现，已创建了该通用SPL框架。
With this framework almost all source files for a board can be reused. No code duplication or symlinking is necessary anymore.
有了这个框架，板子的几乎所有源文件都可以重用。不再需要代码重复或符号链接。

How it works
------------

The object files for SPL are built separately and placed in the "spl" directory.
SPL的目标文件是单独构建的，并放置在“ spl”目录中。
The final binaries which are generated are u-boot-spl, u-boot-spl.bin and u-boot-spl.map.
生成的最终二进制文件是u-boot-spl，u-boot-spl.bin和u-boot-spl.map。
A config option named CONFIG_SPL_BUILD is enabled by Kconfig for SPL.
Kconfig为SPL启用了名为CONFIG_SPL_BUILD的配置选项。
Source files can therefore be compiled for SPL with different settings.
因此，可以使用不同的设置为SPL编译源文件。
For example:

ifeq ($(CONFIG_SPL_BUILD),y)
obj-y += board_spl.o
else
obj-y += board.o
endif

obj-$(CONFIG_SPL_BUILD) += foo.o

#ifdef CONFIG_SPL_BUILD
	foo();
#endif


The building of SPL images can be enabled by CONFIG_SPL option in Kconfig.
可以通过Kconfig中的CONFIG_SPL选项启用SPL映像的构建。
Because SPL images normally have a different text base, one has to be configured by defining CONFIG_SPL_TEXT_BASE. 
由于SPL图像通常具有不同的文本库，因此必须通过定义CONFIG_SPL_TEXT_BASE进行配置。
The linker script has to be defined with CONFIG_SPL_LDSCRIPT.
链接脚本必须使用CONFIG_SPL_LDSCRIPT进行定义。
To support generic U-Boot libraries and drivers in the SPL binary one can optionally define CONFIG_SPL_XXX_SUPPORT. 
为了支持SPL二进制文件中的通用U-Boot库和驱动程序，可以选择定义CONFIG_SPL_XXX_SUPPORT。
Currently following options are supported:

CONFIG_SPL_LIBCOMMON_SUPPORT (common/libcommon.o)
CONFIG_SPL_LIBDISK_SUPPORT (disk/libdisk.o)
CONFIG_SPL_I2C_SUPPORT (drivers/i2c/libi2c.o)
CONFIG_SPL_GPIO_SUPPORT (drivers/gpio/libgpio.o)
CONFIG_SPL_MMC_SUPPORT (drivers/mmc/libmmc.o)
CONFIG_SPL_SERIAL_SUPPORT (drivers/serial/libserial.o)
CONFIG_SPL_SPI_FLASH_SUPPORT (drivers/mtd/spi/libspi_flash.o)
CONFIG_SPL_SPI_SUPPORT (drivers/spi/libspi.o)
CONFIG_SPL_FS_FAT (fs/fat/libfat.o)
CONFIG_SPL_FS_EXT4
CONFIG_SPL_LIBGENERIC_SUPPORT (lib/libgeneric.o)
CONFIG_SPL_POWER_SUPPORT (drivers/power/libpower.o)
CONFIG_SPL_NAND_SUPPORT (drivers/mtd/nand/raw/libnand.o)
CONFIG_SPL_DRIVERS_MISC_SUPPORT (drivers/misc)
CONFIG_SPL_DMA (drivers/dma/libdma.o)
CONFIG_SPL_POST_MEM_SUPPORT (post/drivers/memory.o)
CONFIG_SPL_NAND_LOAD (drivers/mtd/nand/raw/nand_spl_load.o)
CONFIG_SPL_SPI_LOAD (drivers/mtd/spi/spi_spl_load.o)
CONFIG_SPL_RAM_DEVICE (common/spl/spl.c)
CONFIG_SPL_WATCHDOG_SUPPORT (drivers/watchdog/libwatchdog.o)

Device tree
-----------
The U-Boot device tree is filtered by the fdtgrep tools during the build process to generate a much smaller device tree used in SPL (spl/u-boot-spl.dtb) with:
在构建过程中，fdtgrep工具会对U-Boot设备树进行过滤，以生成用于SPL（spl / u-boot-spl.dtb）的更小的设备树，其中包括：
- the mandatory nodes (/alias, /chosen, /config)-强制节点（/ alias，/ chosen，/ config）
- the nodes with one pre-relocation property:-具有一个预重定位属性的节点：
  'u-boot,dm-pre-reloc' or 'u-boot,dm-spl'

fdtgrep is also used to remove:fdtgrep也用于删除：
- the properties defined in CONFIG_OF_SPL_REMOVE_PROPS
-CONFIG_OF_SPL_REMOVE_PROPS中定义的属性
- all the pre-relocation properties-所有预迁移属性
  ('u-boot,dm-pre-reloc', 'u-boot,dm-spl' and 'u-boot,dm-tpl')

All the nodes remaining in the SPL devicetree are bound
(see doc/driver-model/design.rst).

Debugging
---------

When building SPL with DEBUG set you may also need to set CONFIG_PANIC_HANG as in most cases do_reset is not defined within SPL.
在使用DEBUG设置构建SPL时，您可能还需要设置CONFIG_PANIC_HANG，因为在大多数情况下，do_reset在SPL中未定义。

Estimating stack usage
----------------------

With gcc 4.6 (and later) and the use of GNU cflow it is possible to estimate stack usage at various points in run sequence of SPL.  
使用gcc 4.6（和更高版本）并使用GNU cflow，可以估计SPL运行顺序中各个点的堆栈使用情况。
The -fstack-usage option to gcc will produce '.su' files (such as arch/arm/cpu/armv7/syslib.su) that will give stack usage information and cflow can construct program flow.
gcc的-fstack-usage选项将生成“ .su”文件（例如arch / arm / cpu / armv7 / syslib.su），这些文件将提供堆栈使用情况信息，并且cflow可以构造程序流。
Must have gcc 4.6 or later, which supports -fstack-usage
必须具有gcc 4.6或更高版本，该版本支持-fstack-usage
1) Build normally
2) Perform the following shell command to generate a list of C files used in SPL:
2）执行以下shell命令以生成SPL中使用的C文件列表：
$ find spl -name '*.su' | sed -e 's:^spl/::' -e 's:[.]su$:.c:' > used-spl.list
3) Execute cflow:
$ cflow --main=board_init_r `cat used-spl.list` 2>&1 | $PAGER

cflow will spit out a number of warnings as it does not parse the config files and picks functions based on #ifdef. 
cflow不会发出配置文件，而是根据#ifdef选取函数，因此会发出许多警告。
 Parsing the '.i' files instead introduces another set of headaches. 
解析“ .i”文件反而引起了另一组麻烦。
  These warnings are not usually important to understanding the flow, however.
但是，这些警告通常对于了解流程并不重要。