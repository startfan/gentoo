U-Boot for arm64

Summary
=======
The initial arm64 U-Boot port was developed before hardware was available,so the first supported platforms were the Foundation and Fast Model for ARMv8.
最初的arm64 U-Boot端口是在硬件可用之前开发的，因此第一个受支持的平台是ARMv8的基础和快速模型。
These days U-Boot runs on a variety of 64-bit capable ARM hardware, from embedded development boards to servers.
如今，U-Boot可在从嵌入式开发板到服务器的各种支持64位的ARM硬件上运行。

Notes
=====

1. U-Boot can run at any exception level it is entered in, it is recommened to enter it in EL3 if U-Boot takes some responsibilities of aclassical firmware (like initial hardware setup, CPU errata workarounds
   or SMP bringup). 
   U-Boot可以在其​​输入的任何异常级别上运行，如果U-Boot承担了一些经典固件的职责（例如初始硬件设置，CPU勘误解决方法或SMP提起），则建议将其输入EL3。
   U-Boot can be entered in EL2 when its main purpose is that of a boot loader. It can drop to lower exception levels before entering the OS.
   当U-Boot的主要用途是引导加载程序时，可以将其输入EL2。在进入操作系统之前，它可以降低到较低的异常级别。

2. U-Boot for arm64 is compiled with AArch64-gcc. AArch64-gcc use rela relocation format, a tool(tools/relocate-rela) by Scott Wood is used to encode the initial addend of rela to u-boot.bin. After running,the U-Boot will be relocated to destination again.
用于arm64的U-Boot使用AArch64-gcc进行编译。 AArch64-gcc使用rela重定位格式，斯科特·伍德（Scott Wood）使用的工具（tools / relocate-rela）用于将rela的初始加数编码为u-boot.bin。运行后，U-Boot将再次重新定位到目的地。
3. Earlier Linux kernel versions required the FDT to be placed at a 2 MB boundary and within the same 512 MB section as the kernel image, resulting in fdt_high to be defined specially.
早期的Linux内核版本要求将FDT放置在2 MB边界处，并且与内核映像位于同一512 MB区域之内，从而导致fdt_high需要特别定义。
   Since kernel version 4.2 Linux is more relaxed about the DT location, so it can be placed anywhere in memory.
   由于Linux的内核版本4.2更宽松，因此可以将其放置在内存中的任何位置。
   Please reference linux/Documentation/arm64/booting.txt for detail.
   请参考linux / Documentation / arm64 / booting.txt以获得详细信息。

4. Spin-table is used to wake up secondary processors. One location (or per processor location) is defined to hold the kernel entry point for secondary processors. 
Spin-table用于唤醒辅助处理器。定义了一个位置（或每个处理器位置）来保存辅助处理器的内核入口点.
It must be ensured that the location is accessible and zero immediately after secondary processor enter slave_cpu branch execution in start.S. 
必须确保该位置可访问，并且辅助处理器在start.S中进入slave_cpu分支执行后立即将其设置为零。
The location address is encoded in cpu node of DTS. 
位置地址在DTS的cpu节点中编码。
Linux kernel store the entry point of secondary processors to it and send event to wakeup secondary processors.
Linux内核向其存储辅助处理器的入口点，并将事件发送到唤醒辅助处理器。
   Please reference linux/Documentation/arm64/booting.txt for detail.

5. Generic board is supported.

6. CONFIG_ARM64 instead of CONFIG_ARMV8 is used to distinguish aarch64 and aarch32 specific codes.
CONFIG_ARM64代替CONFIG_ARMV8用于区分aarch64和aarch32特定代码。


Contributors
============
   Tom Rini            <trini@ti.com>
   Scott Wood          <scottwood@freescale.com>
   York Sun            <yorksun@freescale.com>
   Simon Glass         <sjg@chromium.org>
   Sharma Bhupesh      <bhupesh.sharma@freescale.com>
   Rob Herring         <robherring2@gmail.com>
   Sergey Temerkhanov  <s.temerkhanov@gmail.com>
